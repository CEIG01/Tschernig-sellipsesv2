<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tscherning's Ellipse</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background:#000;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  font-family: Arial, Helvetica, sans-serif;
  overflow-x:hidden;
}

/* App title */
#app-header {
  width:100%;
  max-width:700px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 14px 4px 14px;
}
#app-title {
  color:#FEE600;
  font-size:17px;
  font-weight:bold;
  letter-spacing:0.04em;
}
#app-subtitle {
  color:#FEE600;
  font-size:11px;
  letter-spacing:0.04em;
  padding:0 14px 8px 14px;
  width:100%;
  max-width:700px;
  opacity:0.7;
}

/* Hamburger button */
#hamburger-btn {
  background:none;
  border:none;
  cursor:pointer;
  padding:6px;
  display:flex;
  flex-direction:column;
  gap:5px;
  -webkit-tap-highlight-color:transparent;
}
#hamburger-btn span {
  display:block;
  width:22px;
  height:2px;
  background:#FEE600;
  border-radius:2px;
}

/* Hamburger drawer */
#hamburger-drawer {
  display:none;
  width:100%;
  max-width:700px;
  background:#0d0d0d;
  border:1px solid #222;
  border-radius:8px;
  padding:14px 18px;
  margin-bottom:4px;
}
#hamburger-drawer.open { display:block; }
#hamburger-drawer h3 {
  color:#FEE600;
  font-size:11px;
  letter-spacing:0.14em;
  margin-bottom:10px;
}
#detail-stats {
  display:grid;
  grid-template-columns:auto auto;
  gap:5px 20px;
  font-size:13px;
}
#detail-stats .ds-label { color:#FEE600; }
#detail-stats .ds-value { color:#FEE600; text-align:right; font-weight:bold; }

#hint {
  color:#444;
  font-size:11px;
  letter-spacing:0.16em;
  text-align:center;
  padding:4px 0 2px 0;
  min-height:20px;
}
#svgwrap {
  width:100%;
  max-width:700px;
  touch-action:none;
  cursor:crosshair;
}
#svgwrap svg {
  width:100%;
  height:auto;
  display:block;
}

/* Lens cross-section panel */
#lens-panel {
  display:none;
  width:100%;
  max-width:700px;
  background:#0a0a0a;
  border-top:1px solid #1a1a1a;
  padding:8px 16px 14px 16px;
}
#lens-panel.visible { display:block; }
#lens-title {
  font-size:10px;
  letter-spacing:0.14em;
  color:#FEE600;
  text-align:center;
  margin-bottom:4px;
}
#best-form-label {
  font-size:11px;
  font-weight:bold;
  letter-spacing:0.1em;
  color:#FEE600;
  text-align:center;
  margin-bottom:6px;
}
#lens-row {
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:0;
  flex-wrap:nowrap;
  width:100%;
}
#lens-canvas {
  display:block;
  border-radius:4px;
  flex-shrink:0;
}

/* Primary stats -- always visible, large and yellow */
#lens-stats {
  display:grid;
  grid-template-columns:auto auto;
  gap:5px 16px;
  font-size:13px;
  align-self:center;
  flex-shrink:0;
  padding-left:14px;
}
.ls-label { color:#FEE600; font-size:11px; }
.ls-value { color:#FEE600; text-align:right; font-weight:bold; font-size:14px; }

/* Power lookup bar + Play bar -- unified single row */
#controls-bar {
  width:100%;
  max-width:700px;
  display:flex;
  align-items:center;
  gap:10px;
  padding:6px 14px 4px 14px;
}
#power-label {
  color:#FEE600;
  font-size:12px;
  font-weight:bold;
  letter-spacing:0.08em;
  white-space:nowrap;
}
#power-input {
  background:#111;
  border:1.5px solid #444;
  border-radius:50px;
  color:#FEE600;
  font-size:14px;
  font-weight:bold;
  font-family:Arial,sans-serif;
  padding:6px 10px;
  width:82px;
  text-align:center;
  outline:none;
  -webkit-appearance:none;
}
#power-input:focus { border-color:#FEE600; }
#power-go {
  background:#111;
  border:2px solid #FEE600;
  border-radius:50px;
  color:#FEE600;
  font-size:13px;
  font-weight:bold;
  font-family:Arial,sans-serif;
  letter-spacing:0.1em;
  padding:6px 18px;
  cursor:pointer;
  -webkit-tap-highlight-color:transparent;
  user-select:none;
}
#power-go:active { background:#1a1a00; }
#power-result {
  color:#666;
  font-size:11px;
  white-space:nowrap;
}
/* divider between power section and play section */
#controls-divider {
  width:1px;
  height:20px;
  background:#333;
  flex-shrink:0;
}
#play-btn {
  background:#111;
  border:2px solid #FEE600;
  border-radius:50px;
  color:#FEE600;
  font-family:Arial,sans-serif;
  font-size:13px;
  font-weight:bold;
  letter-spacing:0.12em;
  padding:6px 18px;
  cursor:pointer;
  transition:background 0.15s;
  -webkit-tap-highlight-color:transparent;
  user-select:none;
  white-space:nowrap;
  flex-shrink:0;
}
#play-btn:hover { background:#1a1a00; }
#play-btn.playing { border-color:#ff4444; color:#ff4444; }
#play-progress {
  flex:1;
  height:3px;
  background:#1a1a1a;
  border-radius:2px;
  overflow:hidden;
  min-width:30px;
}
#play-bar-fill {
  height:100%;
  width:0%;
  background:#FEE600;
  border-radius:2px;
}
</style>
</head>
<body>

<div id="app-header">
  <div id="app-title">Tscherning's Ellipse</div>
  <button id="hamburger-btn" aria-label="More details">
    <span></span><span></span><span></span>
  </button>
</div>
<div id="app-subtitle">The ideal base curve for zero astigmatic aberration</div>

<!-- Hamburger drawer -- secondary details -->
<div id="hamburger-drawer">
  <h3>LENS DETAILS</h3>
  <div id="detail-stats"></div>
</div>

<div id="hint">TOUCH OR DRAG ACROSS THE ELLIPSE</div>

<div id="controls-bar">
  <span id="power-label">POWER</span>
  <input id="power-input" type="number" step="0.25" placeholder="0.00"/>
  <button id="power-go">GO</button>
  <span id="power-result"></span>
  <div id="controls-divider"></div>
  <button id="play-btn">&#9654; PLAY</button>
  <div id="play-progress"><div id="play-bar-fill"></div></div>
</div>

<div id="svgwrap">
  <svg id="mainsvg" xmlns="http://www.w3.org/2000/svg" viewBox="220 30 960 840">

    <rect x="220" y="30" width="960" height="840" fill="#000"/>

    <!-- GRID X every 2D -->
    <line stroke="#222" stroke-width="1" x1="270.91" y1="30" x2="270.91" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="319.97" y1="30" x2="319.97" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="369.02" y1="30" x2="369.02" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="418.08" y1="30" x2="418.08" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="467.13" y1="30" x2="467.13" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="516.19" y1="30" x2="516.19" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="565.24" y1="30" x2="565.24" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="614.29" y1="30" x2="614.29" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="663.35" y1="30" x2="663.35" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="712.40" y1="30" x2="712.40" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="761.46" y1="30" x2="761.46" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="810.51" y1="30" x2="810.51" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="908.62" y1="30" x2="908.62" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="957.67" y1="30" x2="957.67" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="1006.73" y1="30" x2="1006.73" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="1055.78" y1="30" x2="1055.78" y2="700"/>
    <line stroke="#222" stroke-width="1" x1="1104.83" y1="30" x2="1104.83" y2="700"/>

    <!-- GRID Y every 2D -->
    <line stroke="#222" stroke-width="1" x1="220" y1="641.57" x2="1180" y2="641.57"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="546.33" x2="1180" y2="546.33"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="498.71" x2="1180" y2="498.71"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="451.09" x2="1180" y2="451.09"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="403.47" x2="1180" y2="403.47"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="355.85" x2="1180" y2="355.85"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="308.23" x2="1180" y2="308.23"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="260.61" x2="1180" y2="260.61"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="212.99" x2="1180" y2="212.99"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="165.37" x2="1180" y2="165.37"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="117.75" x2="1180" y2="117.75"/>
    <line stroke="#222" stroke-width="1" x1="220" y1="70.13"  x2="1180" y2="70.13"/>

    <!-- ZERO AXES colour coded -->
    <line stroke="#00D4FF" stroke-width="2.5" x1="220" y1="593.95" x2="1180" y2="593.95"/>
    <line stroke="#FF8C00" stroke-width="2.5" x1="859.56" y1="30" x2="859.56" y2="700"/>

    <!-- ELLIPSE -->
    <path stroke="#FEE600" stroke-width="5" fill="rgba(254,230,0,0.04)" stroke-miterlimit="10"
      d="M930.58,357.51c-175.35,137.66-392.76,227.59-545.57,227.59c-166.7,0-151.21-130.36,20.16-268.68c171.37-138.32,387.79-221.07,526.37-228.5c188.76-10.13,174.92,131.52-.96,269.6Z"/>

    <!-- DASHED LINES -->
    <line id="hline" x1="0" y1="0" x2="0" y2="0"
      stroke="#FF8C00" stroke-width="2.5" stroke-dasharray="17 7" stroke-miterlimit="10" display="none"/>
    <line id="vline" x1="0" y1="0" x2="0" y2="0"
      stroke="#00D4FF" stroke-width="2.5" stroke-dasharray="17 7" stroke-miterlimit="10" display="none"/>

    <!-- CIRCLE ON ELLIPSE -->
    <circle id="ptcircle" cx="0" cy="0" r="13"
      fill="none" stroke="#FEE600" stroke-width="4" stroke-miterlimit="10" display="none"/>

    <!-- X axis tick labels (CYAN) every 2D from -20 -->
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="369.02" y="616">-20</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="418.08" y="616">-18</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="467.13" y="616">-16</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="516.19" y="616">-14</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="565.24" y="616">-12</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="614.29" y="616">-10</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="663.35" y="616">-8</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="712.40" y="616">-6</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="761.46" y="616">-4</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="810.51" y="616">-2</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="859.56" y="616">0</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="908.62" y="616">+2</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="957.67" y="616">+4</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="1006.73" y="616">+6</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="1055.78" y="616">+8</text>
    <text fill="#00D4FF" font-family="Arial" font-size="20" text-anchor="middle" x="1104.83" y="616">+10</text>

    <!-- Y axis tick labels (ORANGE) every 2D -->
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="600">0</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="550">+2</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="505">+4</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="458">+6</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="410">+8</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="363">+10</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="315">+12</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="268">+14</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="220">+16</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="173">+18</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="125">+20</text>
    <text fill="#FF8C00" font-family="Arial" font-size="20" text-anchor="end" x="853" y="78">+22</text>

    <!-- AXIS NAME LABELS -->
    <text fill="#00D4FF" font-family="Arial" font-size="26" font-weight="bold"
      text-anchor="start" x="369.02" y="648">Back Vertex Power (D)</text>
    <text fill="#FF8C00" font-family="Arial" font-size="26" font-weight="bold"
      text-anchor="start" x="866" y="58">Front Base Curve (D)</text>

    <!-- LIVE READING LABELS -->
    <text id="labelX" font-family="Arial" font-size="44" font-weight="bold"
      fill="#00D4FF" text-anchor="middle" x="0" y="700" display="none"/>
    <text id="labelY" font-family="Arial" font-size="44" font-weight="bold"
      fill="#FF8C00" text-anchor="end" x="853" y="0" display="none"/>

    <!-- POWER LOOKUP: dual branch markers -->
    <!-- Wollaston (upper) branch marker -->
    <line id="pw-vline" stroke="#FEE600" stroke-width="1.5" stroke-dasharray="6,4"
      x1="0" y1="30" x2="0" y2="870" display="none"/>
    <circle id="pw-upper-pt" r="8" fill="none" stroke="#FF8C00" stroke-width="2.5" display="none"/>
    <circle id="pw-lower-pt" r="8" fill="none" stroke="#00D4FF" stroke-width="2.5" display="none"/>

  </svg>
</div>

<!-- LENS CROSS-SECTION PANEL -->
<div id="lens-panel">
  <div id="lens-title">LENS CROSS-SECTION</div>
  <div id="best-form-label">BEST FORM</div>
  <div id="lens-row">
    <canvas id="lens-canvas" width="260" height="200"></canvas>
    <div id="lens-stats"></div>
  </div>
</div>

<script>
/* ── Axis mapping ── */
var ZERO_X    = 859.56;
var ZERO_Y    = 593.95;
var PX_PER_DX = 24.527;
var PX_PER_DY = 23.810;

function svgToRx(svgX) { return (svgX - ZERO_X) / PX_PER_DX; }
function svgToF1(svgY) { return (ZERO_Y - svgY) / PX_PER_DY; }

/* ── Bezier ellipse ── */
var segs = [
  { p0:[930.58,357.51], cp1:[755.23,495.17], cp2:[537.82,585.10], p3:[385.01,585.10] },
  { p0:[385.01,585.10], cp1:[218.31,585.10], cp2:[233.80,454.74], p3:[405.17,316.42] },
  { p0:[405.17,316.42], cp1:[576.54,178.10], cp2:[792.96,95.35],  p3:[931.54,87.92]  },
  { p0:[931.54,87.92],  cp1:[1120.30,77.79], cp2:[1106.46,219.44],p3:[930.58,357.52] }
];

function bezierPt(seg, t) {
  var mt=1-t, p0=seg.p0, p1=seg.cp1, p2=seg.cp2, p3=seg.p3;
  return [
    mt*mt*mt*p0[0]+3*mt*mt*t*p1[0]+3*mt*t*t*p2[0]+t*t*t*p3[0],
    mt*mt*mt*p0[1]+3*mt*mt*t*p1[1]+3*mt*t*t*p2[1]+t*t*t*p3[1]
  ];
}

var samples = [];
for (var s=0; s<segs.length; s++) {
  for (var ti=0; ti<=400; ti++) {
    samples.push(bezierPt(segs[s], ti/400));
  }
}

function closestEllipsePt(svgX, svgY) {
  var best=null, bestD=Infinity;
  for (var i=0; i<samples.length; i++) {
    var dx=samples[i][0]-svgX, dy=samples[i][1]-svgY;
    var d=dx*dx+dy*dy;
    if (d<bestD){ bestD=d; best=samples[i]; }
  }
  return best;
}

/* ── SVG element refs ── */
var hline    = document.getElementById('hline');
var vlineEl  = document.getElementById('vline');
var ptcircle = document.getElementById('ptcircle');
var labelX   = document.getElementById('labelX');
var labelY   = document.getElementById('labelY');
var hint     = document.getElementById('hint');

function show(el){ el.removeAttribute('display'); }
function hide(el){ el.setAttribute('display','none'); }
function set(el,a,v){ el.setAttribute(a,String(v)); }

function fmt(v) {
  var s = Math.round(v/0.25)*0.25;
  return (s>=0?'+':'')+s.toFixed(2)+'D';
}

/* ── Lens cross-section ── */
var lc   = document.getElementById('lens-canvas');
var lctx = lc.getContext('2d');
var dpr  = window.devicePixelRatio || 1;

/* Canvas is ALWAYS this fixed size -- never changes */
var LC_W  = 230;  // wider to give arrow label room on left
var LC_H  = 220;
lc.width        = LC_W * dpr;
lc.height       = LC_H * dpr;
lc.style.width  = LC_W + 'px';
lc.style.height = LC_H + 'px';
lctx.scale(dpr, dpr);

/* Front vertex always at this fixed X -- lens grows rightward */
var FV_X = 38;  // pushed right to give arrow + label room

var N_GLASS   = 1.5;
var LENS_DIAM = 70;  // 70mm uncut blank

function sag(r_mm, h_mm) {
  if (!isFinite(r_mm) || Math.abs(r_mm) < 1e-6) return 0;
  var r = Math.abs(r_mm);
  return h_mm >= r ? r : r - Math.sqrt(r*r - h_mm*h_mm);
}

function drawLens(F1_D, F_D) {
  var F2_D  = F_D - F1_D;
  var r1_mm = F1_D !== 0 ? (N_GLASS-1)/F1_D*1000  : Infinity;
  var r2_mm = F2_D !== 0 ? -(N_GLASS-1)/F2_D*1000 : Infinity;

  /* ── Semi-diameter: 35mm default (70mm blank), reduce only if radius < 35mm ── */
  var h = LENS_DIAM / 2;  // 35mm
  if (isFinite(r1_mm) && Math.abs(r1_mm) < h) h = Math.abs(r1_mm) * 0.97;
  if (isFinite(r2_mm) && Math.abs(r2_mm) < h) h = Math.abs(r2_mm) * 0.97;
  h = Math.max(h, 4);

  var s1 = sag(r1_mm, h);
  var s2 = isFinite(r2_mm) ? sag(r2_mm, h) : 0;

  /* ── Centre thickness ── */
  var ct;
  if (F_D >= 0) {
    ct = (!isFinite(r2_mm) || r2_mm > 0)
      ? Math.max(2.0, 1.0 + s1 - s2)
      : Math.max(2.0, 1.0 + s1 + s2);
  } else {
    ct = 1.5;
  }

  /* ── Scale: fixed px-per-mm based on 70mm blank (h=35) filling canvas ── */
  var scale = (LC_H * 0.45) / 35;  // 35mm semi-diam fills 90% of half-height
  var hPx   = h  * scale;
  var cyL   = LC_H / 2;

  var r1Px  = isFinite(r1_mm) ? Math.abs(r1_mm)*scale : 1e6;
  var r2Px  = isFinite(r2_mm) ? Math.abs(r2_mm)*scale : 1e6;
  var ctPx  = ct * scale;
  var s1Px  = s1 * scale;
  var s2Px  = s2 * scale;

  /* ── X positions: front vertex FIXED at FV_X, lens grows rightward ── */
  var xFV = FV_X;
  var xBV = xFV + ctPx;
  var xFR = xFV + s1Px;
  var xBR = isFinite(r2_mm)
    ? (r2_mm > 0 ? xBV + s2Px : xBV - s2Px)
    : xBV;

  var cx1 = xFV + r1Px;
  var cx2 = isFinite(r2_mm) ? xBV + (r2_mm > 0 ? r2Px : -r2Px) : xBV + 1e6;

  /* ── Clear and redraw on fixed canvas ── */
  lctx.clearRect(0, 0, LC_W, LC_H);
  lctx.fillStyle = '#050505';
  lctx.fillRect(0, 0, LC_W, LC_H);

  /* ── Optical axis ── */
  lctx.strokeStyle = '#1a2a3a'; lctx.lineWidth=1; lctx.setLineDash([4,4]);
  lctx.beginPath(); lctx.moveTo(0, cyL); lctx.lineTo(LC_W, cyL); lctx.stroke();
  lctx.setLineDash([]);

  /* ── Arc point sampler ── */
  function arcPts(acx, acy, ar, yStart, yEnd, leftSide) {
    var pts=[], steps=80;
    for (var i=0; i<=steps; i++) {
      var y  = yStart + (i/steps)*(yEnd-yStart);
      var d2 = ar*ar - (y-acy)*(y-acy);
      if (d2<0) continue;
      pts.push([leftSide ? acx-Math.sqrt(d2) : acx+Math.sqrt(d2), y]);
    }
    return pts;
  }

  /* ── Draw lens ── */
  lctx.beginPath();

  var fp = r1Px < 9e5
    ? arcPts(cx1, cyL, r1Px, cyL-hPx, cyL+hPx, true)
    : [[xFV, cyL-hPx],[xFV, cyL+hPx]];
  lctx.moveTo(fp[0][0], fp[0][1]);
  for (var i=0; i<fp.length; i++) lctx.lineTo(fp[i][0], fp[i][1]);

  lctx.lineTo(xBR, cyL+hPx);

  var bp;
  if (!isFinite(r2_mm) || r2Px >= 9e5) {
    bp = [[xBR, cyL+hPx],[xBR, cyL-hPx]];
  } else if (r2_mm > 0) {
    bp = arcPts(cx2, cyL, r2Px, cyL+hPx, cyL-hPx, true);
  } else {
    bp = arcPts(cx2, cyL, r2Px, cyL+hPx, cyL-hPx, false);
  }
  for (var i=0; i<bp.length; i++) lctx.lineTo(bp[i][0], bp[i][1]);

  lctx.lineTo(xFR, cyL-hPx);
  lctx.closePath();

  lctx.fillStyle = 'rgba(100,180,255,0.13)';
  lctx.fill();
  lctx.strokeStyle = '#74b9ff';
  lctx.lineWidth = 2;
  lctx.stroke();

  /* ── Diameter double-headed arrow -- always cyan ── */
  var diam_mm = h * 2;
  var arrowColor = '#00D4FF';

  var arrowX   = 14;
  var arrowTop = cyL - hPx;
  var arrowBot = cyL + hPx;
  var arrowLen = arrowBot - arrowTop;
  var AH = Math.min(8, arrowLen * 0.12);

  lctx.save();
  lctx.strokeStyle = arrowColor;
  lctx.fillStyle   = arrowColor;
  lctx.lineWidth   = 1.5;

  lctx.beginPath();
  lctx.moveTo(arrowX, arrowTop + AH);
  lctx.lineTo(arrowX, arrowBot - AH);
  lctx.stroke();

  lctx.beginPath();
  lctx.moveTo(arrowX, arrowTop);
  lctx.lineTo(arrowX - 4, arrowTop + AH);
  lctx.lineTo(arrowX + 4, arrowTop + AH);
  lctx.closePath(); lctx.fill();

  lctx.beginPath();
  lctx.moveTo(arrowX, arrowBot);
  lctx.lineTo(arrowX - 4, arrowBot - AH);
  lctx.lineTo(arrowX + 4, arrowBot - AH);
  lctx.closePath(); lctx.fill();

  lctx.lineWidth = 1;
  lctx.beginPath();
  lctx.moveTo(arrowX - 5, arrowTop); lctx.lineTo(arrowX + 5, arrowTop);
  lctx.moveTo(arrowX - 5, arrowBot); lctx.lineTo(arrowX + 5, arrowBot);
  lctx.stroke();

  var diagLabel = diam_mm.toFixed(1) + 'mm';
  lctx.save();
  lctx.translate(arrowX - 6, cyL);
  lctx.rotate(-Math.PI / 2);
  lctx.font = 'bold 10px Arial';
  lctx.textAlign = 'center';
  lctx.textBaseline = 'middle';
  lctx.fillStyle = arrowColor;
  lctx.fillText(diagLabel, 0, 0);
  lctx.restore();

  lctx.restore();

  /* ── Stats ── */
  function fmtD(v)  { return (v>0?'+':'')+(isFinite(v)?v.toFixed(2):'inf')+'D'; }
  function fmtMM(v) { return isFinite(v)?Math.abs(v).toFixed(1)+' mm':'inf'; }
  var et = (isFinite(r2_mm) && r2_mm < 0) ? ct-s2-s1 : ct+s2-s1;

  document.getElementById('lens-stats').innerHTML =
    '<span class="ls-label">Front Base</span><span class="ls-value">'  + fmtD(F1_D)  + '</span>' +
    '<span class="ls-label">Blank \u00d8</span><span class="ls-value">' + diam_mm.toFixed(1)+' mm</span>' +
    '<span class="ls-label">CT</span><span class="ls-value">'           + ct.toFixed(2)+' mm</span>' +
    '<span class="ls-label">ET</span><span class="ls-value">'           + Math.max(0,et).toFixed(2)+' mm</span>';

  /* ── Secondary stats (hamburger drawer) ── */
  document.getElementById('detail-stats').innerHTML =
    '<span class="ds-label">Front (F\u2081)</span><span class="ds-value">'  + fmtD(F1_D)  + '</span>' +
    '<span class="ds-label">Back (F\u2082)</span><span class="ds-value">'   + fmtD(F2_D)  + '</span>' +
    '<span class="ds-label">r\u2081</span><span class="ds-value">'          + fmtMM(r1_mm)+ '</span>' +
    '<span class="ds-label">r\u2082</span><span class="ds-value">'          + fmtMM(r2_mm)+ '</span>' +
    '<span class="ds-label">n</span><span class="ds-value">'                + N_GLASS     + '</span>';
}

/* ── Interaction ── */
function getSVGCoords(e) {
  var rect = document.getElementById('svgwrap').getBoundingClientRect();
  var scaleX=960/rect.width, scaleY=840/rect.height;
  var cx=e.touches?e.touches[0].clientX:e.clientX;
  var cy=e.touches?e.touches[0].clientY:e.clientY;
  return { svgX:220+(cx-rect.left)*scaleX, svgY:30+(cy-rect.top)*scaleY };
}

function update(e) {
  var c  = getSVGCoords(e);
  var pt = closestEllipsePt(c.svgX, c.svgY);
  if (!pt) return;
  clearPowerMarkers();
  document.getElementById('power-input').value = '';
  var ptX=pt[0], ptY=pt[1];
  var rx = Math.round(svgToRx(ptX)/0.25)*0.25;
  var f1 = Math.round(svgToF1(ptY)/0.25)*0.25;
  renderPoint(ptX, ptY, rx, f1);
}

function clearAll() {
  hide(hline); hide(vlineEl); hide(ptcircle); hide(labelX); hide(labelY);
  hint.textContent = 'TOUCH OR DRAG ACROSS THE ELLIPSE';
  document.getElementById('lens-panel').classList.remove('visible');
}

/* ── SVG interaction -- handles both freehand drag and power-mode tap ── */
var wrap = document.getElementById('svgwrap');

/* Snap radius in SVG units -- generous for finger tap accuracy */
var SNAP_RADIUS_SVG = 60;

function distSq(ax, ay, bx, by) { return (ax-bx)*(ax-bx)+(ay-by)*(ay-by); }

function trySnapToPowerPoint(svgX, svgY) {
  /* Returns true if a power marker was close enough and we snapped to it */
  if (pwUpperPt.getAttribute('display') === 'none' &&
      pwLowerPt.getAttribute('display') === 'none') return false;

  var snapR2 = SNAP_RADIUS_SVG * SNAP_RADIUS_SVG;
  var upperX = parseFloat(pwUpperPt.getAttribute('cx')||0);
  var upperY = parseFloat(pwUpperPt.getAttribute('cy')||0);
  var lowerX = parseFloat(pwLowerPt.getAttribute('cx')||0);
  var lowerY = parseFloat(pwLowerPt.getAttribute('cy')||0);

  var dUpper = (pwUpperPt.getAttribute('display') !== 'none')
    ? distSq(svgX, svgY, upperX, upperY) : Infinity;
  var dLower = (pwLowerPt.getAttribute('display') !== 'none')
    ? distSq(svgX, svgY, lowerX, lowerY) : Infinity;

  if (dUpper < snapR2 || dLower < snapR2) {
    /* Snap to whichever is closer */
    var useUpper = dUpper < dLower;
    var px = useUpper ? upperX : lowerX;
    var py = useUpper ? upperY : lowerY;
    var rx = Math.round(svgToRx(px)/0.25)*0.25;
    var f1 = Math.round(svgToF1(py)/0.25)*0.25;
    renderPoint(px, py, rx, f1);
    return true;
  }

  /* Tapped elsewhere while in power mode -- close power mode */
  clearPowerMarkers();
  document.getElementById('power-input').value = '';
  document.getElementById('power-result').textContent = '';
  return false;
}

wrap.addEventListener('mousemove', function(e) {
  if (!isPlaying) {
    /* In power mode, don't drag-update */
    if (pwUpperPt.getAttribute('display') !== 'none' ||
        pwLowerPt.getAttribute('display') !== 'none') return;
    update(e);
  }
});
wrap.addEventListener('mouseleave', function() {
  if (!isPlaying) {
    if (pwUpperPt.getAttribute('display') !== 'none' ||
        pwLowerPt.getAttribute('display') !== 'none') return;
    clearAll();
  }
});
wrap.addEventListener('click', function(e) {
  if (!isPlaying) {
    var c = getSVGCoords(e);
    if (!trySnapToPowerPoint(c.svgX, c.svgY)) {
      update(e);
    }
  }
});
wrap.addEventListener('touchstart', function(e) {
  if (!isPlaying) {
    e.preventDefault();
    var c = getSVGCoords(e);
    if (!trySnapToPowerPoint(c.svgX, c.svgY)) {
      update(e);
    }
  }
},{passive:false});
wrap.addEventListener('touchmove', function(e) {
  if (!isPlaying) {
    if (pwUpperPt.getAttribute('display') !== 'none' ||
        pwLowerPt.getAttribute('display') !== 'none') {
      e.preventDefault(); return;
    }
    e.preventDefault(); update(e);
  }
},{passive:false});
wrap.addEventListener('touchend', function(e) {
  if (!isPlaying) e.preventDefault();
},{passive:false});

/* ── Play animation ── */
var PLAY_DURATION = 20000; // 20 seconds for one full loop
var isPlaying     = false;
var playStart     = null;
var playRaf       = null;

var playBtn     = document.getElementById('play-btn');
var barFill     = document.getElementById('play-bar-fill');

/* Build a clean ordered sample array that traverses the ellipse
   starting from the leftmost point (most negative Rx) and going
   clockwise: lower branch left-to-right, then upper branch right-to-left. */
function buildPlaySamples() {
  /* Trace the 4 bezier segments in order at high resolution.
     This gives a single continuous path around the ellipse -- no sorting,
     no branch splitting, guaranteed no jumps.                             */
  var pts = [];
  var STEPS_PER_SEG = 300;
  for (var s=0; s<segs.length; s++) {
    for (var ti=0; ti<=STEPS_PER_SEG; ti++) {
      pts.push(bezierPt(segs[s], ti/STEPS_PER_SEG));
    }
  }
  return pts;
}

var playSamples = buildPlaySamples();

function renderAtSample(pt) {
  var ptX = pt[0], ptY = pt[1];
  var rx  = Math.round(svgToRx(ptX)/0.25)*0.25;
  var f1  = Math.round(svgToF1(ptY)/0.25)*0.25;
  renderPoint(ptX, ptY, rx, f1);
}

function playFrame(timestamp) {
  if (!playStart) playStart = timestamp;
  var elapsed  = timestamp - playStart;
  var progress = elapsed / PLAY_DURATION;

  if (progress >= 1) {
    // Completed one full loop
    progress = 1;
    var pt = playSamples[playSamples.length-1];
    renderAtSample(pt);
    barFill.style.width = '100%';
    stopPlay();
    return;
  }

  // Interpolate along playSamples
  var idx     = progress * (playSamples.length - 1);
  var idxLow  = Math.floor(idx);
  var idxHigh = Math.min(idxLow+1, playSamples.length-1);
  var t       = idx - idxLow;
  var ptA     = playSamples[idxLow];
  var ptB     = playSamples[idxHigh];
  var pt      = [ ptA[0]+(ptB[0]-ptA[0])*t, ptA[1]+(ptB[1]-ptA[1])*t ];

  renderAtSample(pt);
  barFill.style.width = (progress*100).toFixed(2)+'%';
  playRaf = requestAnimationFrame(playFrame);
}

function startPlay() {
  isPlaying = true;
  playStart = null;
  playBtn.textContent = '■ STOP';
  playBtn.classList.add('playing');
  barFill.style.width = '0%';
  playRaf = requestAnimationFrame(playFrame);
}

function stopPlay() {
  isPlaying = false;
  if (playRaf) cancelAnimationFrame(playRaf);
  playRaf = null;
  playBtn.textContent = '▶ PLAY';
  playBtn.classList.remove('playing');
}

playBtn.addEventListener('click', function() {
  if (isPlaying) stopPlay(); else startPlay();
});

/* ── Hamburger toggle ── */
document.getElementById('hamburger-btn').addEventListener('click', function() {
  var d = document.getElementById('hamburger-drawer');
  d.classList.toggle('open');
});

/* ── Power lookup ── */
var pwVline      = document.getElementById('pw-vline');
var pwUpperPt    = document.getElementById('pw-upper-pt');
var pwLowerPt    = document.getElementById('pw-lower-pt');

function clearPowerMarkers() {
  hide(pwVline); hide(pwUpperPt);
  hide(pwLowerPt);
  document.getElementById('power-result').textContent = '';
}

function findBranchPoints(targetRx) {
  /* Scan all samples for points within 0.5D of targetRx.
     Split into upper (lower SVG y = higher F1) and lower branch. */
  var svgTargetX = ZERO_X + targetRx * PX_PER_DX;
  var tolerance  = PX_PER_DX * 0.5; // 0.5D tolerance in px

  var candidates = samples.filter(function(pt) {
    return Math.abs(pt[0] - svgTargetX) < tolerance;
  });

  if (candidates.length === 0) return null;

  /* Split by Y: upper branch has smaller SVG y (higher F1 value) */
  candidates.sort(function(a,b){ return a[1]-b[1]; }); // ascending SVG y

  /* Find the two extremes -- topmost and bottommost y candidates */
  var upper = candidates[0];                          // smallest y = highest F1
  var lower = candidates[candidates.length - 1];      // largest y  = lowest F1

  /* Refine: find the sample closest to svgTargetX within each half */
  var midY = (upper[1] + lower[1]) / 2;
  var topCands    = candidates.filter(function(p){ return p[1] <= midY; });
  var bottomCands = candidates.filter(function(p){ return p[1] >  midY; });

  function closest(arr) {
    return arr.reduce(function(best, p) {
      return Math.abs(p[0]-svgTargetX) < Math.abs(best[0]-svgTargetX) ? p : best;
    });
  }

  upper = topCands.length    ? closest(topCands)    : null;
  lower = bottomCands.length ? closest(bottomCands) : null;

  return { upper: upper, lower: lower };
}

function showPowerPoints(targetRx) {
  var pts = findBranchPoints(targetRx);
  if (!pts || (!pts.upper && !pts.lower)) {
    document.getElementById('power-result').textContent = 'not on ellipse';
    clearPowerMarkers();
    return;
  }

  /* Hide the live base curve label -- marker labels replace it */
  hide(labelY);

  /* Vertical power line */
  var svgX = ZERO_X + targetRx * PX_PER_DX;
  set(pwVline, 'x1', svgX); set(pwVline, 'x2', svgX);
  show(pwVline);

  if (pts.upper) {
    var uf1 = Math.round(svgToF1(pts.upper[1])/0.25)*0.25;
    set(pwUpperPt, 'cx', pts.upper[0]); set(pwUpperPt, 'cy', pts.upper[1]); show(pwUpperPt);
  }

  if (pts.lower) {
    var lf1 = Math.round(svgToF1(pts.lower[1])/0.25)*0.25;
    set(pwLowerPt, 'cx', pts.lower[0]); set(pwLowerPt, 'cy', pts.lower[1]); show(pwLowerPt);

    /* Drive the main crosshair and lens to lower (Ostwalt) by default */
    var rx = Math.round(svgToRx(pts.lower[0])/0.25)*0.25;
    renderPoint(pts.lower[0], pts.lower[1], rx, lf1);
  }

  document.getElementById('power-result').textContent =
    pts.upper && pts.lower ? '2 solutions' : '1 solution';
}

/* Shared render -- drives crosshair + lens from any source */
function renderPoint(ptX, ptY, rx, f1) {
  set(hline,'x1',ptX); set(hline,'y1',ptY); set(hline,'x2',ZERO_X); set(hline,'y2',ptY); show(hline);
  set(vlineEl,'x1',ptX); set(vlineEl,'y1',ptY); set(vlineEl,'x2',ptX); set(vlineEl,'y2',ZERO_Y); show(vlineEl);
  set(ptcircle,'cx',ptX); set(ptcircle,'cy',ptY); show(ptcircle);
  set(labelX,'x',ptX); set(labelX,'y',700);
  labelX.textContent = fmt(rx); show(labelX);
  if (ptX < ZERO_X) {
    set(labelY,'x', ZERO_X+12); set(labelY,'text-anchor','start');
  } else {
    set(labelY,'x', ZERO_X-12); set(labelY,'text-anchor','end');
  }
  set(labelY,'y', ptY+16);
  labelY.textContent = fmt(f1); show(labelY);
  hint.textContent = '';
  document.getElementById('lens-panel').classList.add('visible');
  drawLens(f1, rx);
}

function doPowerLookup() {
  var raw = parseFloat(document.getElementById('power-input').value);
  if (isNaN(raw)) {
    document.getElementById('power-result').textContent = 'enter a value';
    return;
  }
  var rx = Math.round(raw / 0.25) * 0.25;
  clearPowerMarkers();
  showPowerPoints(rx);
}

document.getElementById('power-go').addEventListener('click', doPowerLookup);
document.getElementById('power-input').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') doPowerLookup();
});

</script>
</body>
</html>
